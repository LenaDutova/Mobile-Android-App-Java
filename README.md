# Работа с сетью с помощью Retrofit клиента 
Retrofit - это типобезопасный HTTP-клиент для Android и Java. https://square.github.io/retrofit/
Его особенность заключается в том, что он позволяет осуществлять асинхронные запросы по сети в фоновом потоке (вне UI), а возвращать данные уже на стороне интерфейса. Таким образом не требуется самостоятельный запуск фонового потока и возврат данных в UI

## Зависимости
Само по себе мобильное приложение не имеет прав на использование сети. Добавим это разрешение и разрешение на проверку состояния сети в файле AndroidManifest.xml:
```
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
```

Для использования библиотеки Retrofit требуется добавить зависимости в build.gradle.kts уровня Модуля:
```
implementation("com.squareup.retrofit2:retrofit:3.0.0")
implementation("com.squareup.retrofit2:converter-gson:3.0.0")
```

А также подключить конвертер JSON-данных на ваш выбор. Например добавим библиотеку GSON:
```
implementation("com.google.code.gson:gson:2.13.2")
```

## Описание данных (models)
Структура документов, которые будут читаться из сети должны быть описана в формате POJO-классов либо с публичными параметрами, либо с приватными параметрами, но публичными конструкторами и методами доступа. 

Чаще всего библиотеки для конвертирования, как например GSON, могут собирать созвучные имена пропуская символы-разделители, например "user_name" из json будет записан в параметр "userName". Но в случае сильного расхождения, можно указать соответствие названий через аннотацию:
```
@SerializedName("punchline")
private final String delivery;
```

Значения примитивных типов будут записаны, а вот для иных значений стоит убедится в наличии соответствующего класса в вашем проекте.

## Описание API (service)
Следующий шаг заключается в описании контракта (интерфейса) всех возможных запросов к серверу, с указанием возвращаемых данных, входных параметров, с возможной перегрузкой методов или передаваемыми параметрами по умолчанию. Для каждого метода требуется указать аннотацию (@GET или @POST) и соответствующим поддоменом запроса. 
```
@GET("count/10")
Call<List<JokeModel>> getJokes ();
```

В адреса запроса можно вставлять параметры (примитивных типов). Для этого параметр вставки указывается в фигурных скобках, а соответсвующее ему значение из атрибутов помечается аннотацией @Path:
```
@GET("count/{count}")
Call<List<JokeModel>> getJokes (@Path("count") int count);
```

Также через аннотацию @Query можно дополнять запрос, указывая иные критерии (если их реализует выбранное RESTfull API)

## Создание клиента 
Для того чтобы начать взаимодействие с сетью необходимо связать url-адрес выбранного сервиса, созданный контракт и выбранный конвертер (возможно прописать обработку ошибок, количество повторов соединения и пр.)
```
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(ApiService.URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build();
ApiService apiService = retrofit.create(ApiService.class);
```

Старайтесь переиспользовать ранее созданный клиент, а не пересоздавать его под каждый запрос. Для этого можно либо воспользоваться паттерном "Одиночка (Singleton)" или инициализировать клиент в Application-классе вашего приложения.

## Осуществление запроса
На объекте клиента можно вызвать методы, описанные в контракте. Сделать это можно в двух режимах - синхронном (execute) и асинхронном (enqueue). В первом случае придется самостоятельно создавать фоновый поток, в котором следует стартовать загрузку данных, а потом пытаться "пробросить" данные обратно в главный поток. execute-запрос применяется для операций, сопровождаемых лаконичным ответом (например, подтверждение загрузки файла от мобильного приложения на сервер), или с использованием сторонних библиотек (например, RXJava), которые возьмут на себя межпоточное взаимодействие. 

При enqueue-запросе необходимо передать два обратных вызова для взаимодействия в случае успеха и провала передачи данных. При успешном запросе, должен вернуться код 200 и данные, которые можно прочитать из body() полученного от сервера ответа. При провале нередко стоит уточнить состоятия сети и уведомить об этом пользователя (например, попросить включить wi-fi или мобильный интернет)
```
apiService.getJokes().enqueue(new Callback<List<JokeModel>>() {
    @Override
    public void onResponse(@NonNull Call<List<JokeModel>> call, @NonNull Response<List<JokeModel>> response) {
        if (response.isSuccessful() && response.body() != null) {
            for (JokeModel joke: response.body()) Log.d ("TAG", joke.toString());
        }else {
            Log.d ("TAG", "Responce code: " + response.code());
        }
    }
    @Override
    public void onFailure(@NonNull Call<List<DenoJoke>> call, @NonNull Throwable t) {
        Log.e ("TAG", t.getMessage());
    }
});
```

Помните, что "тяжеловесные" операции нельзя выполнять в главном (UI) потоке, так как это приведет к "зависанию" интерфейса (пользователь не сможет взаимодействовать с приложением). Такое поведенеие верный признак того, что операционная система Android "убъёт" подобное приложение